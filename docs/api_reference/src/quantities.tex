%!TEX root = std.tex
\rSec0[qties]{Quantities library}

\rSec1[qties.summary]{Summary}

\pnum
This Clause describes components for dealing with quantities,
as summarized in \tref{qties.summary}.

\begin{modularlibsumtab}{Quantities library summary}{qties.summary}
\ref{qty.helpers}       & Helpers                                & \tcode{mp_units.core} \\
\ref{qty.expr.temp}     & Expression template                    & \\
\ref{qty.dim}           & Dimension                              & \\
\ref{qty.spec}          & Quantity specification                 & \\
\ref{qty.mag}           & Magnitude                              & \\
\ref{qty.unit}          & Unit                                   & \\
\ref{qty.ref}           & Reference                              & \\
\ref{qty.rep}           & Representation                         & \\
\ref{qty.types}         & Quantity types                         & \\ \rowsep
\ref{qty.systems}       & Systems                                & \tcode{mp_units.systems} \\
\ref{qty.chrono}        & \tcode{std::chrono} compatibility      & \\
\end{modularlibsumtab}

\rSec1[mp.units.syn]{Module \tcode{mp_units} synopsis}
\indexmodule{mp_units}%
\begin{codeblock}
export module mp_units;

export import mp_units.core;
export import mp_units.systems;
\end{codeblock}

\rSec1[mp.units.core.syn]{Module \tcode{mp_units.core} synopsis}
\indexmodule{mp_units.core}%
\begin{codeblock}
export module mp_units.core;

import std;

export namespace mp_units {

enum class @\libglobal{text_encoding}@ : std::int8_t { @\libmember{utf8}{text_encoding}@, @\libmember{portable}{text_encoding}@, @\libmember{default_encoding}{text_encoding}@ = utf8 };

enum class @\libglobal{quantity_character}@ { @\libmember{scalar}{quantity_character}@, @\libmember{complex}{quantity_character}@, @\libmember{vector}{quantity_character}@, @\libmember{tensor}{quantity_character}@ };

// \ref{qty.helpers}, helpers

// \ref{qty.symbol.text}, class template \tcode{symbol_text}

// \ref{qty.expr.temp}, expression template

// \ref{qty.expr.temp.types}, types

template<typename... Ts>
struct type_list;

template<typename T, typename... Ts>
struct per;

template<typename F, int Num, int... Den>
  requires @\seebelownc@
struct power;

// \ref{qty.dim}, dimension

// \ref{qty.dim.concepts}, concepts

template<typename T>
concept Dimension = @\seebelownc@;

template<typename T, auto D>
concept DimensionOf = @\seebelownc@;

// \ref{qty.dim.types}, types

template<symbol_text Symbol>
struct base_dimension;

template<@\seebelownc@>
struct derived_dimension;

struct dimension_one;
inline constexpr dimension_one dimension_one = @\seebelownc@;

consteval @\libconcept{Dimension}@ auto @\liboverload{inverse}{\cname{Dimension}}@(@\libconcept{Dimension}@ auto d) { return dimension_one / d; }

template<std::intmax_t Num, std::intmax_t Den = 1, @\libconcept{Dimension}@ D>
  requires(Den != 0)
consteval @\libconcept{Dimension}@ auto pow(D d);
consteval @\libconcept{Dimension}@ auto @\liboverload{sqrt}{\cname{Dimension}}@(@\libconcept{Dimension}@ auto d) { return pow<1, 2>(d); }
consteval @\libconcept{Dimension}@ auto @\liboverload{cbrt}{\cname{Dimension}}@(@\libconcept{Dimension}@ auto d) { return pow<1, 3>(d); }

struct @\libglobal{dimension_symbol_formatting}@ {
  text_encoding encoding = text_encoding::default_encoding;
};

template<typename CharT = char, std::@\stdconcept{output_iterator}@<CharT> Out, @\libconcept{Dimension}@ D>
constexpr Out dimension_symbol_to(Out out, D d, const dimension_symbol_formatting& fmt = {});

template<dimension_symbol_formatting fmt = {}, typename CharT = char, @\libconcept{Dimension}@ D>
constexpr auto dimension_symbol(D);

// \ref{qty.spec}, quantity specification

// \ref{qty.spec.concepts}, concepts

template<typename T>
concept QuantitySpec = @\seebelownc@;

template<QuantitySpec Q>
consteval @\seebelownc@ get_kind(Q q);

template<typename T, auto QS>
concept QuantitySpecOf = @\seebelownc@;

// \ref{qty.spec.types}, types

struct is_kind;
inline constexpr is_kind is_kind = @\seebelownc@;

template<auto...>
struct quantity_spec;  // \notdef

template<@\exposconceptnc{BaseDimension}@ auto Dim, auto... Args>
  requires @\seebelownc@
struct quantity_spec<Dim, Args...>;

template<@\exposconceptnc{DerivedQuantitySpec}@ auto Eq, auto... Args>
  requires @\seebelownc@
struct quantity_spec<Eq, Args...>;

template<@\exposconceptnc{NamedQuantitySpec}@ auto QS, auto... Args>
  requires @\seebelownc@
struct quantity_spec<QS, Args...>;

template<@\exposconceptnc{NamedQuantitySpec}@ auto QS, @\exposconceptnc{DerivedQuantitySpec}@ auto Eq, auto... Args>
  requires @\seebelownc@
struct quantity_spec<QS, Eq, Args...>;

template<@\exposconceptnc{DerivedQuantitySpecExpr}@... Expr>
struct derived_quantity_spec;

struct dimensionless;
inline constexpr dimensionless dimensionless = @\seebelownc@;

template<typename Q>
  requires @\seebelownc@
struct kind_of_;
template<auto Q>
  requires requires { typename kind_of_<decltype(Q)>; }
inline constexpr kind_of_<Q> @\libglobal{kind_of}@{};

consteval @\libconcept{QuantitySpec}@ auto @\liboverload{inverse}{\cname{QuantitySpec}}@(@\libconcept{QuantitySpec}@ auto q) { return dimensionless / q; }

template<std::intmax_t Num, std::intmax_t Den = 1, @\libconcept{QuantitySpec}@ Q>
  requires(Den != 0)
consteval @\libconcept{QuantitySpec}@ auto pow(Q q);
consteval @\libconcept{QuantitySpec}@ auto @\liboverload{sqrt}{\cname{QuantitySpec}}@(@\libconcept{QuantitySpec}@ auto q) { return pow<1, 2>(q); }
consteval @\libconcept{QuantitySpec}@ auto @\liboverload{cbrt}{\cname{QuantitySpec}}@(@\libconcept{QuantitySpec}@ auto q) { return pow<1, 3>(q); }

consteval bool implicitly_convertible(@\libconcept{QuantitySpec}@ auto from, @\libconcept{QuantitySpec}@ auto to);
consteval bool explicitly_convertible(@\libconcept{QuantitySpec}@ auto from, @\libconcept{QuantitySpec}@ auto to);
consteval bool castable(@\libconcept{QuantitySpec}@ auto from, @\libconcept{QuantitySpec}@ auto to);
consteval bool interconvertible(@\libconcept{QuantitySpec}@ auto qs1, @\libconcept{QuantitySpec}@ auto qs2);

template<@\libconcept{QuantitySpec}@ Q>
consteval @\exposconceptnc{QuantityKindSpec}@ auto get_kind(Q q);

consteval @\libconcept{QuantitySpec}@ auto get_common_quantity_spec(@\libconcept{QuantitySpec}@ auto... qs)
  requires @\seebelownc@;

// \ref{qty.mag}, magnitude

// \ref{qty.unit}, unit

// \ref{qty.ref}, reference

// \ref{qty.rep}, representation

// \ref{qty.rep.traits}, traits

// \ref{qty.fp.traits}, floating-point

template<typename Rep>
constexpr bool treat_as_floating_point = @\seebelownc@;

// \ref{qty.set.traits}, set

template<typename Rep>
constexpr bool is_scalar = @\seebelownc@;

template<typename Rep>
constexpr bool is_complex = false;

template<typename Rep>
constexpr bool is_vector = false;

template<typename Rep>
constexpr bool is_tensor = false;

// \ref{qty.rep.concepts}, concepts

template<typename T>
concept Representation = @\seebelownc@;

template<typename T, quantity_character Ch>
concept RepresentationOf = @\seebelownc@;

// \ref{qty.types}, quantity types

// \ref{qty.traits}, traits

// \ref{qty.val.traits}, values

template<typename Rep>
struct quantity_values;

// \ref{qty.compat.traits}, compatibility

template<typename T>
struct quantity_like_traits; // \notdef

template<typename T>
struct quantity_point_like_traits; // \notdef

template<typename T>
concept quantity_like = @\seebelownc@;

template<typename T>
concept quantity_point_like = @\seebelownc@;

// \ref{qty.concepts}, quantity concepts

// \ref{qty}, class template \tcode{quantity}
template<@\libconcept{Reference}@ auto R, @\libconcept{RepresentationOf}@<get_quantity_spec(R).character> Rep = double>
class quantity;

// \ref{qty.pt.concepts}, quantity point concepts

// \ref{qty.pt}, class template \tcode{quantity_point}
template<@\unspec@>
class quantity_point;

}
\end{codeblock}

\rSec1[mp.units.systems.syn]{Module \tcode{mp_units.systems} synopsis}
\indexmodule{mp_units.systems}%
\begin{codeblock}
export module mp_units.systems;

export import mp_units.core;
import std;

export namespace mp_units {

// \ref{qty.chrono}, \tcode{std::chrono} compatibility

template<typename Rep, typename Period>
struct quantity_like_traits<std::chrono::duration<Rep, Period>>;

template<typename Clock>
struct chrono_point_origin_;
template<typename Clock>
constexpr chrono_point_origin_<Clock> @\libglobal{chrono_point_origin}@{};

template<typename Clock, typename Rep, typename Period>
struct quantity_point_like_traits<
  std::chrono::time_point<Clock, std::chrono::duration<Rep, Period>>>;

}
\end{codeblock}

\rSec1[qty.helpers]{Helpers}

\rSec2[qty.helpers.non.types]{Non-types}

\begin{itemdecl}
template<typename T>
concept @\defexposconceptnc{tag-type}@ = type_is_empty(^T) && type_is_final(^T);  // \expos
\end{itemdecl}

\begin{itemdecl}
consteval bool @\exposidnc{is-specialization-of}@(  // \expos
  std::meta::info type, std::meta::info template_name);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{is_type(type) \&\& is_class_template(template_name)} is \tcode{true}.

\pnum
\returns
\tcode{has_template_arguments(type) \&\& template_of(type) == template_name}.
\end{itemdescr}

\begin{itemdecl}
consteval bool @\exposidnc{is-convertible-to-base-subobject-of}@(  // \expos
  std::meta::info type, std::meta::info template_name);
\end{itemdecl}

\begin{itemdescr}
\pnum
\expects
\tcode{is_type(type) \&\& is_class_template(template_name)} is \tcode{true}.

\pnum
\returns
\tcode{true} if
\tcode{[:type:]} has an unambiguous and accessible base
that is a specialization of \tcode{[:template_name:]}, and
\tcode{false} otherwise.
\end{itemdescr}

\rSec2[qty.ratio]{Struct \exposid{ratio}}

\begin{codeblock}
namespace mp_units {

struct @\exposidnc{ratio}@ {  // \expos
  std::intmax_t num;
  std::intmax_t den;

  consteval @\exposidnc{ratio}@(std::intmax_t n, std::intmax_t d = 1);

  friend consteval bool operator==(@\exposidnc{ratio}@, @\exposidnc{ratio}@) = default;
  friend consteval auto operator<=>(@\exposidnc{ratio}@ lhs, @\exposidnc{ratio}@ rhs) { return (lhs - rhs).num <=> 0; }

  friend consteval @\exposidnc{ratio}@ operator-(@\exposidnc{ratio}@ r) { return @\exposidnc{ratio}@{-r.num, r.den}; }

  friend consteval @\exposidnc{ratio}@ operator+(@\exposidnc{ratio}@ lhs, @\exposidnc{ratio}@ rhs)
  {
    return @\exposidnc{ratio}@{lhs.num * rhs.den + lhs.den * rhs.num, lhs.den * rhs.den};
  }

  friend consteval @\exposidnc{ratio}@ operator-(@\exposidnc{ratio}@ lhs, @\exposidnc{ratio}@ rhs) { return lhs + (-rhs); }

  friend consteval @\exposidnc{ratio}@ operator*(@\exposidnc{ratio}@ lhs, @\exposidnc{ratio}@ rhs);

  friend consteval @\exposidnc{ratio}@ operator/(@\exposidnc{ratio}@ lhs, @\exposidnc{ratio}@ rhs) { return lhs* @\exposidnc{ratio}@{rhs.den, rhs.num}; }
};

consteval bool is_integral(@\exposidnc{ratio}@ r) { return r.num % r.den == 0; }

consteval @\exposidnc{ratio}@ common_ratio(@\exposidnc{ratio}@ r1, @\exposidnc{ratio}@ r2)
{
  if (r1.num == r2.num && r1.den == r2.den) return r1;

  // $\operatorname{gcd}(a/b, c/d) = \operatorname{gcd}(ad, cb) / bd$
  contract_assert(std::numeric_limits<std::intmax_t>::max() / r1.num > r2.den);
  contract_assert(std::numeric_limits<std::intmax_t>::max() / r2.num > r1.den);
  contract_assert(std::numeric_limits<std::intmax_t>::max() / r1.den > r2.den);

  const std::intmax_t num = std::gcd(r1.num * r2.den, r2.num * r1.den);
  const std::intmax_t den = r1.den * r2.den;
  const std::intmax_t gcd = std::gcd(num, den);
  return @\exposidnc{ratio}@{num / gcd, den / gcd};
}

}
\end{codeblock}

\begin{itemdecl}
consteval @\exposidnc{ratio}@(std::intmax_t n, std::intmax_t d = 1);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{N} and \tcode{D} be the values of \tcode{n} and \tcode{d}.
Let \tcode{R} be \tcode{std::ratio<N, D>}.

\pnum
\effects
Equivalent to: \tcode{R}.

\pnum
\ensures
\tcode{num == R::num \&\& den == R::den} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
friend consteval @\exposidnc{ratio}@ operator*(@\exposidnc{ratio}@ lhs, @\exposidnc{ratio}@ rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{R(r)} be \tcode{std::ratio<N, D>},
where \tcode{N} and \tcode{D} are the values of \tcode{r.num} and \tcode{r.den}.
Let \tcode{Res} be \tcode{std::ratio_multiply<R(lhs), R(rhs)>}.

\pnum
\effects
Equivalent to: \tcode{return \exposidnc{ratio}\{Res::num, Res::den\}}.
\end{itemdescr}

\rSec2[qty.fixed.string]{Class template \exposidnc{basic-fixed-string}}

\rSec2[qty.symbol.text]{Class template \tcode{symbol_text}}

\rSec1[qty.expr.temp]{Expression template}

\rSec2[qty.expr.temp.general]{General}

\pnum
Subclause \ref{qty.expr.temp} specifies the components
used to maintain an ordered, simplified, and readable
argument lists in the names of specializations.
\begin{example}
The framework ensures the following assertion holds.
\begin{codeblock}
using namespace si::unit_symbols;
static_assert(^decltype(km / square(h)) ==
              ^derived_unit<si::kilo_<si::metre>, per<power<non_si::hour, 2>>>);
\end{codeblock}
\end{example}

\rSec2[qty.expr.temp.types]{Types}

\begin{codeblock}
namespace mp_units {

template<typename... Ts>
struct @\libglobal{type_list}@ {};

}
\end{codeblock}

\pnum
\tcode{type_list} encapsulates a list of types.

\begin{codeblock}
namespace mp_units {

template<typename T, typename... Ts>
struct @\libglobal{per}@ {};

}
\end{codeblock}

\pnum
\tcode{per} stores the arguments with negative exponents.

\begin{codeblock}
namespace mp_units {

template<typename F, int Num, int... Den>
  requires(sizeof...(Den) <= 1 && @\exposidnc{valid-ratio}@(Num, Den...) && @\exposidnc{positive-ratio}@(Num, Den...) &&
           !@\exposidnc{ratio-one}@(Num, Den...))
struct @\libglobal{power}@ {
  using factor = F;
  static constexpr @\exposidnc{ratio}@ exponent{Num, Den...};
};

}
\end{codeblock}

\pnum
\tcode{power} represents a power\irefiev{102-02-08}
of the form $\tcode{F}^{\tcode{Num}/\tcode{Den}}$.
\begin{note}
\tcode{Den} is optional to shorten the type name when \tcode{Den} is \tcode{1}.
\end{note}

\rSec2[qty.expr.temp.algo]{Algorithms}

\pnum
Unless otherwise specified, in the following descriptions, let
\begin{itemize}
\item
\tcode{To} be the template of the resulting type list, and
\item
\tcode{OneType} be the neutral element\irefiev{102-01-19} of the operation.
\end{itemize}

\begin{codeblock}
consteval std::meta::info @\exposidnc{expr-type}@(std::meta::info t)
{
  return @\exposidnc{is-specialization-of}@(t, ^power) ? template_arguments_of(t)[0] : t;
}

template<typename Lhs, typename Rhs>
struct @\exposidnc{type-less}@ :
    std::bool_constant<@\exposidnc{is-specialization-of}@(^Rhs, ^power) ||
                       display_string_of(@\exposidnc{expr-type}@(^Lhs)) <
                         display_string_of(@\exposidnc{expr-type}@(^Rhs))> {
};
\end{codeblock}

\begin{codeblock}
template<typename OneType, typename... Ts>
struct @\exposidnc{expr-fractions}@ {
  using @\exposidnc{num}@ = @\seebelownc@;
  using @\exposidnc{den}@ = @\seebelownc@;
}
\end{codeblock}

\pnum
\exposidnc{expr-fractions} divides an expression template to numerator and denominator parts.
\exposidnc{num} is TBD.
\exposidnc{den} is TBD.

\begin{itemdecl}
template<template<typename...> typename To, typename OneType,
         template<typename, typename> typename Pred = @\exposidnc{type-less}@, typename Lhs, typename Rhs>
consteval auto @\exposidnc{expr-multiply}@(Lhs, Rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\exposidnc{expr-multiply} multiplies two sorted expression templates.

\pnum
\effects
TBD.

\pnum
\returns
TBD.
\end{itemdescr}

\begin{itemdecl}
template<template<typename...> typename To, typename OneType,
         template<typename, typename> typename Pred = @\exposidnc{type-less}@, typename Lhs, typename Rhs>
consteval auto @\exposidnc{expr-divide}@(Lhs lhs, Rhs rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\exposidnc{expr-divide} divides two sorted expression templates.

\pnum
\effects
TBD.

\pnum
\returns
TBD.
\end{itemdescr}

\begin{itemdecl}
template<template<typename...> typename To, typename OneType, typename T>
consteval auto @\exposidnc{expr-invert}@(T);
\end{itemdecl}

\begin{itemdescr}
\pnum
\exposidnc{expr-invert} inverts the expression template \tcode{T}.

\pnum
\effects
TBD.

\pnum
\returns
TBD.
\end{itemdescr}

\begin{itemdecl}
template<std::intmax_t Num, std::intmax_t Den, template<typename...> typename To,
         typename OneType, template<typename, typename> typename Pred = @\exposidnc{type-less}@, typename T>
  requires(Den != 0)
consteval auto @\exposidnc{expr-pow}@(T);
\end{itemdecl}

\begin{itemdescr}
\pnum
\exposidnc{expr-pow} computes the power\irefiev{102-02-08} $\tcode{T}^{\tcode{Num}/\tcode{Den}}$.

\pnum
\effects
TBD.

\pnum
\returns
TBD.
\end{itemdescr}

\begin{itemdecl}
template<template<typename> typename Proj, template<typename...> typename To, typename OneType,
         template<typename, typename> typename Pred = @\exposidnc{type-less}@, @\exposidnc{expr-projectable}@<Proj> T>
consteval auto @\exposidnc{expr-map}@(T);
\end{itemdecl}

\begin{itemdescr}
\pnum
\exposidnc{expr-map} maps contents of one expression template to another resulting in a different type list.

\pnum
Let \tcode{Proj} be projection used for mapping, and
let \tcode{T} be the expression template to map from.

\pnum
\effects
TBD.

\pnum
\returns
TBD.
\end{itemdescr}

\rSec1[qty.dim]{Dimension}

\rSec2[qty.dim.general]{General}

\pnum
Subclause \ref{qty.dim} specifies the components
for defining the dimension of a quantity\irefiev{112-01-11}.

\rSec2[qty.dim.concepts]{Concepts}

\begin{itemdecl}
template<typename T>
concept @\deflibconcept{Dimension}@ = @\exposconceptnc{tag-type}@<T> && std::@\stdconcept{derived_from}@<T, @\exposidnc{dimension-interface}@>;

template<typename T>
concept @\defexposconceptnc{BaseDimension}@ = @\libconcept{Dimension}@<T> && std::@\stdconcept{derived_from}@<T, base_dimension>;

consteval bool @\exposidnc{is-dimension-one}@(std::meta::info type_alias) {
  return dealias(type_alias) == ^dimension_one;
}

template<typename T>
concept @\defexposconceptnc{IsPowerOfDim}@ =
  (@\exposidnc{is-specialization-of}@(^T, ^power) &&
   (@\exposconceptnc{BaseDimension}@<typename T::factor> || @\exposidnc{is-dimension-one}@(^typename T::factor)));

template<typename T>
constexpr bool @\exposidnc{is-per-of-dims}@ = false;

template<typename... Ts>
constexpr bool @\exposidnc{is-per-of-dims}@<per<Ts...>> =
  (... && (@\exposconceptnc{BaseDimension}@<Ts> || @\exposidnc{is-dimension-one}@(^Ts) || @\exposconceptnc{IsPowerOfDim}@<Ts>));

template<typename T>
concept @\defexposconceptnc{DerivedDimensionExpr}@ =
  @\exposconceptnc{BaseDimension}@<T> || @\exposidnc{is-dimension-one}@(^T) || @\exposconceptnc{IsPowerOfDim}@<T> || @\exposidnc{is-per-of-dims}@<T>;

template<auto D1, auto D2>
concept @\defexposconceptnc{SameDimension}@ = @\libconcept{Dimension}@<decltype(D1)> && @\libconcept{Dimension}@<decltype(D2)> && D1 == D2;

template<typename T, auto D>
concept @\deflibconcept{DimensionOf}@ = @\libconcept{Dimension}@<T> && @\libconcept{Dimension}@<decltype(D)> && @\exposconceptnc{SameDimension}@<T{}, D>;
\end{itemdecl}

\rSec2[qty.dim.types]{Types}

\begin{codeblock}
namespace mp_units {

struct @\exposidnc{dimension-interface}@ {
  friend consteval @\libconcept{Dimension}@ auto operator*(@\libconcept{Dimension}@ auto lhs, @\libconcept{Dimension}@ auto rhs)
  {
    return @\exposidnc{expr-multiply}@<derived_dimension, struct dimension_one>(lhs, rhs);
  }

  friend consteval @\libconcept{Dimension}@ auto operator/(@\libconcept{Dimension}@ auto lhs, @\libconcept{Dimension}@ auto rhs)
  {
    return @\exposidnc{expr-divide}@<derived_dimension, struct dimension_one>(lhs, rhs);
  }

  friend consteval bool operator==(@\libconcept{Dimension}@ auto lhs, @\libconcept{Dimension}@ auto rhs)
  {
    return ^decltype(lhs) == ^decltype(rhs);
  }
};

template<symbol_text Symbol>
struct @\libglobal{base_dimension}@ : @\exposidnc{dimension-interface}@ {
  static constexpr auto symbol = Symbol;
};

}
\end{codeblock}

\pnum
\tcode{base_dimension} is used by the program
to define the dimension of a base quantity\irefiev{112-01-08}.
\begin{example}
\begin{codeblock}
inline constexpr struct dim_length final : base_dimension<"L"> {} dim_length;
\end{codeblock}
\end{example}

\begin{codeblock}
namespace mp_units {

template<@\exposconceptnc{DerivedDimensionExpr}@... Expr>
struct @\exposidnc{derived-dimension-impl}@ : @\exposidnc{expr-fractions}@<dimension_one, Expr...> {};

template<@\exposconceptnc{DerivedDimensionExpr}@... Expr>
struct @\libglobal{derived_dimension}@ final : @\exposidnc{dimension-interface}@, @\exposidnc{derived-dimension-impl}@<Expr...> {};

}
\end{codeblock}

\pnum
\tcode{derived_dimension} is used by the library
to represent the dimension of a derived quantity\irefiev{112-01-10}.
\begin{example}
\begin{codeblock}
constexpr auto acceleration = isq::dim_speed / isq::dim_time;
static_assert(dealias(^decltype(acceleration)) ==
              ^derived_dimension<isq::dim_length, per<power<isq::dim_time, 2>>>);
\end{codeblock}
\end{example}

\pnum
\mandates
\tcode{Expr...} is simplified\iref{qty.expr.temp.algo}.
\begin{note}
The library handles the representation of a derived dimension.
The name is not \expos{} for the portability and readability of the specializations.
\end{note}

\begin{codeblock}
namespace mp_units {

inline constexpr struct @\libglobal{dimension_one}@ final : @\exposidnc{dimension-interface}@, @\exposidnc{derived-dimension-impl}@<> {
} @\libglobal{dimension_one}@;

}
\end{codeblock}

\pnum
\tcode{dimension_one} represents the dimension of a quantity of dimension one\irefiev{112-01-13}.

\begin{itemdecl}
template<std::intmax_t Num, std::intmax_t Den = 1, @\libconcept{Dimension}@ D>
  requires(Den != 0)
consteval @\libconcept{Dimension}@ auto @\liboverload{pow}{\cname{Dimension}}@(D d);
\end{itemdecl}

\begin{itemdescr}
\pnum
Computes $\tcode{d}^{\tcode{Num}/\tcode{Den}}$.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if constexpr (@\exposconceptnc{BaseDimension}@<D>) {
  if constexpr (Den == 1)
    return derived_dimension<power<D, Num>>{};
  else
    return derived_dimension<power<D, Num, Den>>{};
} else
  return @\exposidnc{expr-pow}@<Num, Den, derived_dimension, struct dimension_one>(d);
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template<typename CharT = char, std::@\stdconcept{output_iterator}@<CharT> Out, @\libconcept{Dimension}@ D>
constexpr Out @\libglobal{dimension_symbol_to}@(Out out, D d, const dimension_symbol_formatting& fmt = {});
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
TBD.

\pnum
\returns
TBD.
\end{itemdescr}

\begin{itemdecl}
template<dimension_symbol_formatting fmt = {}, typename CharT = char, @\libconcept{Dimension}@ D>
constexpr auto @\libglobal{dimension_symbol}@(D);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
TBD.
\end{codeblock}
\end{itemdescr}

\rSec1[qty.spec]{Quantity specification}

\rSec2[qty.spec.general]{General}

\pnum
Subclause \ref{qty.spec} specifies the components
for defining a quantity\irefiev{112-01-01}.

\rSec2[qty.spec.concepts]{Concepts}

\begin{itemdecl}
template<typename T>
concept @\deflibconcept{QuantitySpec}@ = @\exposconceptnc{tag-type}@<T> && std::@\stdconcept{derived_from}@<T, @\exposidnc{quantity-spec-interface-base}@>;

template<typename T>
concept @\defexposconceptnc{QuantityKindSpec}@ = @\exposidnc{is-specialization-of}@(^T, ^kind_of_);

template<typename T>
concept @\defexposconceptnc{NamedQuantitySpec}@ =
  @\libconcept{QuantitySpec}@<T> && std::@\stdconcept{derived_from}@<T, quantity_spec> && !@\exposconceptnc{QuantityKindSpec}@<T>;

consteval bool @\exposidnc{is-dimensionless}@(std::meta::info type_alias) {
  return dealias(type_alias) == ^dimensionless;
}

template<typename T>
concept @\defexposconceptnc{IsPowerOfQuantitySpec}@ =
  (@\exposidnc{is-specialization-of}@(^T, ^power) &&
   (@\exposconceptnc{NamedQuantitySpec}@<typename T::factor> || @\exposidnc{is-dimensionless}@(^typename T::factor)));

template<typename T>
constexpr bool @\exposidnc{is-per-of-quantity-specs}@ = false;

template<typename... Ts>
constexpr bool @\exposidnc{is-per-of-quantity-specs}@<per<Ts...>> =
  (... && (@\exposconceptnc{NamedQuantitySpec}@<Ts> || @\exposidnc{is-dimensionless}@(^Ts) || @\exposconceptnc{IsPowerOfQuantitySpec}@<Ts>));

template<typename T>
concept @\defexposconceptnc{DerivedQuantitySpecExpr}@ = @\exposconceptnc{NamedQuantitySpec}@<T> || @\exposidnc{is-dimensionless}@(^T) ||
                                  @\exposconceptnc{IsPowerOfQuantitySpec}@<T> || @\exposidnc{is-per-of-quantity-specs}@<T>;

template<typename T>
concept @\defexposconceptnc{DerivedQuantitySpec}@ =
  @\libconcept{QuantitySpec}@<T> &&
  (@\exposidnc{is-specialization-of}@(^T, ^derived_quantity_spec) ||
   (@\exposconceptnc{QuantityKindSpec}@<T> && @\exposidnc{is-specialization-of}@(type_remove_const(type_of(^T::@\exposidnc{quantity-spec}@)),
                                                ^derived_quantity_spec)));

template<auto QS1, auto QS2>
concept @\defexposconceptnc{SameQuantitySpec}@ =
  @\libconcept{QuantitySpec}@<decltype(QS1)> && @\libconcept{QuantitySpec}@<decltype(QS2)> && (QS1 == QS2);

template<auto Child, auto Parent>
concept @\defexposconceptnc{ChildQuantitySpecOf}@ = (@\exposidnc{is-child-of}@(Child, Parent));

template<auto To, auto From>
concept @\defexposconceptnc{NestedQuantityKindSpecOf}@ = @\libconcept{QuantitySpec}@<decltype(From)> && @\libconcept{QuantitySpec}@<decltype(To)> &&
                                   !@\exposconceptnc{SameQuantitySpec}@<get_kind(From), get_kind(To)> &&
                                   @\exposconceptnc{ChildQuantitySpecOf}@<To, get_kind(From).@\exposidnc{quantity-spec}@>;

template<auto From, auto To>
concept @\defexposconceptnc{QuantitySpecConvertibleTo}@ =
  @\libconcept{QuantitySpec}@<decltype(From)> && @\libconcept{QuantitySpec}@<decltype(To)> && implicitly_convertible(From, To);

template<auto From, auto To>
concept @\defexposconceptnc{QuantitySpecExplicitlyConvertibleTo}@ =
  @\libconcept{QuantitySpec}@<decltype(From)> && @\libconcept{QuantitySpec}@<decltype(To)> && explicitly_convertible(From, To);

template<auto From, auto To>
concept @\defexposconceptnc{QuantitySpecCastableTo}@ =
  @\libconcept{QuantitySpec}@<decltype(From)> && @\libconcept{QuantitySpec}@<decltype(To)> && castable(From, To);

template<typename T, auto QS>
concept @\deflibconcept{QuantitySpecOf}@ =
  @\libconcept{QuantitySpec}@<T> && @\libconcept{QuantitySpec}@<decltype(QS)> && @\exposconceptnc{QuantitySpecConvertibleTo}@<T{}, QS> &&
  !@\exposconceptnc{NestedQuantityKindSpecOf}@<T{}, QS> &&
  (@\exposconceptnc{QuantityKindSpec}@<T> || !@\exposconceptnc{NestedQuantityKindSpecOf}@<QS, T{}>);
\end{itemdecl}

\rSec2[qty.spec.types]{Types}

\begin{codeblock}
namespace mp_units {

template<@\libconcept{QuantitySpec}@ QS, @\libconcept{Unit}@ U>
  requires(!@\exposconceptnc{AssociatedUnit}@<U>) || @\libconcept{UnitOf}@<U, QS{}>
consteval @\libconcept{Reference}@ auto @\exposidnc{make-reference}@(QS, U u)
{
  if constexpr (@\exposconceptnc{QuantityKindSpec}@<QS>)
    return u;
  else
    return reference<QS, U>{};
}

consteval quantity_character @\exposidnc{common-quantity-character}@(
  std::initializer_list<quantity_character> args)
{
  return max(args);
}

template<typename... Qs1, typename... Qs2>
consteval quantity_character @\exposidnc{derived-quantity-character}@(type_list<Qs1...>, type_list<Qs2...>)
{
  constexpr quantity_character num =
    @\exposidnc{common-quantity-character}@({quantity_character::scalar, [:@\exposidnc{expr-type}@(^Qs1):]::character...});
  constexpr quantity_character den =
    @\exposidnc{common-quantity-character}@({quantity_character::scalar, [:@\exposidnc{expr-type}@(^Qs2):]::character...});
  if constexpr (num == den)
    return quantity_character::scalar;
  else
    return @\exposidnc{common-quantity-character}@({num, den});
}

consteval quantity_character @\exposidnc{quantity-character-init}@(quantity_character ch,
                                                     std::initializer_list<std::meta::info> args)
{
  auto it =
    std::ranges::find_if(args, [](auto arg) { return type_of(arg) == ^quantity_character; });
  if (it != args.end()) return extract<quantity_character>(*it);
  return ch;
}

template<@\defexposconceptnc{NamedQuantitySpec}@ Q>
  requires requires { Q::dimension; }
using @\exposidnc{to-dimension}@ = [:type_remove_const(type_of(^Q::dimension)):];

struct @\exposidnc{quantity-spec-interface-base}@ {
  friend consteval @\libconcept{QuantitySpec}@ auto operator*(@\libconcept{QuantitySpec}@ auto lhs, @\libconcept{QuantitySpec}@ auto rhs)
  {
    return @\exposidnc{clone-kind-of}@<lhs, rhs>(@\exposidnc{expr-multiply}@<derived_quantity_spec, struct dimensionless>(
      @\exposidnc{remove-kind}@(lhs), @\exposidnc{remove-kind}@(rhs)));
  }

  friend consteval @\libconcept{QuantitySpec}@ auto operator/(@\libconcept{QuantitySpec}@ auto lhs, @\libconcept{QuantitySpec}@ auto rhs)
  {
    return @\exposidnc{clone-kind-of}@<lhs, rhs>(@\exposidnc{expr-divide}@<derived_quantity_spec, struct dimensionless>(
      @\exposidnc{remove-kind}@(lhs), @\exposidnc{remove-kind}@(rhs)));
  }

  friend consteval bool operator==(@\libconcept{QuantitySpec}@ auto lhs, @\libconcept{QuantitySpec}@ auto rhs)
  {
    return ^decltype(lhs) == ^decltype(rhs);
  }
};

struct @\exposidnc{quantity-spec-interface}@ : @\exposidnc{quantity-spec-interface-base}@ {
  template<typename Self, @\libconcept{UnitOf}@<Self{}> U>
  consteval @\libconcept{Reference}@ auto operator[](this Self self, U u)
  {
    return @\exposidnc{make-reference}@(self, u);
  }

  template<typename Self, typename FwdQ, @\libconcept{Quantity}@ Q = [:type_remove_cvref(^FwdQ):]>
    requires @\exposconceptnc{QuantitySpecExplicitlyConvertibleTo}@<Q::quantity_spec, Self{}>
  constexpr @\libconcept{Quantity}@ auto operator()(this Self self, FwdQ&& q)
  {
    return quantity{std::forward<FwdQ>(q).@\exposidnc{numerical-value}@, @\exposidnc{make-reference}@(self, Q::unit)};
  }
};

inline constexpr struct @\libglobal{is_kind}@ {
} @\libglobal{is_kind}@;

template<auto Arg>
concept @\defexposconceptnc{quantity-spec-1-arg}@ =
  (type_of(^Arg) == ^quantity_character) &&
  std::ranges::contains(enumerators_of(^quantity_character), value_of(^Arg));

template<auto Lhs, auto Rhs>
concept @\defexposconceptnc{quantity-spec-2-args}@ = (@\exposconceptnc{quantity-spec-1-arg}@<Lhs> && value_of(^Rhs) == is_kind) ||
                               (@\exposconceptnc{quantity-spec-1-arg}@<Rhs> && value_of(^Lhs) == is_kind);

template<int MaxArgs, auto... Args>
concept @\defexposconceptnc{quantity-spec-args}@ =
  (... && !@\libconcept{QuantitySpec}@<decltype(Args)>) &&
  ((sizeof...(Args) == 0) ||  //
   (sizeof...(Args) == 1 && @\exposconceptnc{quantity-spec-1-arg}@<Args...>) ||
   (sizeof...(Args) == 2 && @\exposconceptnc{quantity-spec-2-args}@<Args...> && MaxArgs == 2));

template<@\exposconceptnc{BaseDimension}@ auto Dim, auto... Args>
  requires @\exposconceptnc{quantity-spec-args}@<1, Args...>
struct @\libspec{quantity_spec}{\ecname{BaseDimension}}@<Dim, Args...> : @\exposidnc{quantity-spec-interface}@ {
  using @\exposidnc{base-type}@ = quantity_spec;
  static constexpr @\exposconceptnc{BaseDimension}@ auto dimension = Dim;
  static constexpr quantity_character character =
    @\exposidnc{quantity-character-init}@(quantity_character::scalar, {^Args...});
};

template<@\exposconceptnc{DerivedQuantitySpec}@ auto Eq, auto... Args>
  requires @\exposconceptnc{quantity-spec-args}@<1, Args...>
struct @\libspec{quantity_spec}{\ecname{DerivedQuantitySpec}}@<Eq, Args...> : @\exposidnc{quantity-spec-interface}@ {
  using @\exposidnc{base-type}@ = quantity_spec;
  static constexpr auto @\exposidnc{equation}@ = Eq;
  static constexpr @\libconcept{Dimension}@ auto dimension = Eq.dimension;
  static constexpr quantity_character character =
    @\exposidnc{quantity-character-init}@(Eq.character, {^Args...});
};

template<@\exposconceptnc{NamedQuantitySpec}@ auto QS, auto... Args>
  requires @\exposconceptnc{quantity-spec-args}@<2, Args...>
struct @\libspec{quantity_spec}{\ecname{NamedQuantitySpec}}@<QS, Args...> : @\exposidnc{quantity-spec-interface}@ {
  using @\exposidnc{base-type}@ = quantity_spec;
  static constexpr auto @\exposidnc{parent}@ = QS;  // clang-format off
  static constexpr auto @\exposidnc{equation}@ = @\exposidnc{parent}@.@\exposidnc{equation}@;  // \expos, present only
    // if the \fakegrammarterm{qualified-id} \tcode{\exposidnc{parent}.\exposidnc{equation}} is valid and denotes an object
  static constexpr @\libconcept{Dimension}@ auto dimension = @\exposidnc{parent}@.dimension;  // clang-format on
  static constexpr quantity_character character =
    @\exposidnc{quantity-character-init}@(QS.character, {^Args...});
};

template<@\exposconceptnc{NamedQuantitySpec}@ auto QS, @\exposconceptnc{DerivedQuantitySpec}@ auto Eq, auto... Args>
  requires @\exposconceptnc{quantity-spec-args}@<2, Args...> && @\exposconceptnc{QuantitySpecExplicitlyConvertibleTo}@<Eq, QS>
struct @\libspec{quantity_spec}{<\ecname{NamedQuantitySpec}, \ecname{DerivedQuantitySpec}>}@<QS, Eq, Args...> : @\exposidnc{quantity-spec-interface}@ {
  using @\exposidnc{base-type}@ = quantity_spec;
  static constexpr auto @\exposidnc{parent}@ = QS;
  static constexpr auto @\exposidnc{equation}@ = Eq;
  static constexpr @\libconcept{Dimension}@ auto dimension = @\exposidnc{parent}@.dimension;
  static constexpr quantity_character character =
    @\exposidnc{quantity-character-init}@(Eq.character, {^Args...});
};

}
\end{codeblock}

\pnum
A \defnadj{named}{quantity} is a type that models \exposconceptnc{NamedQuantitySpec}.
A specialization of \tcode{quantity_spec} is used as a base type when defining a named quantity.

\pnum
In the following descriptions, let \tcode{Q} be a named quantity defined used an alluded signature.
The identifier of \tcode{Q} represents its quantity name\irefiev{112-01-02}.

\pnum
Let \tcode{set} be an enumerator of \tcode{quantity_character}.
The possible arguments to \tcode{quantity_spec} are
\begin{itemize}
\item
$(\text{A base quantity dimension}, \opt{\tcode{set}})$,
\item
$(\text{A quantity calculus}, \opt{\tcode{set}})$,
\item
$(\text{A named quantity}, \opt{\tcode{set}}, \opt{\tcode{is_kind}})$, and
\item
$(\text{A named quantity}, \text{a quantity calculus}, \opt{\tcode{set}}, \opt{\tcode{is_kind}})$.
\end{itemize}

\pnum
If the first argument is a base quantity dimension,
then \tcode{Q} is that base quantity\irefiev{112-01-08}.
If an argument is a quantity calculus\irefiev{112-01-30} \placeholder{C},
then $\tcode{Q} = \placeholder{C}$ (a quantity equation\irefiev{112-01-31}).
If the first argument is a named quantity,
then \tcode{Q} is of its kind\irefiev{112-01-04}.

\pnum
\tcode{set} is the set of the numerical value of \tcode{Q}.
If not specified, then it defaults to \tcode{scalar} for the first signature,
and to that of the quantity argument that comes before the \tcode{set} otherwise.
\tcode{is_kind} specifies \tcode{Q} to start a new hierarchy tree of a kind.

\pnum
\begin{example}
\begin{codeblock}
// The first signature defines a base quantity.
inline constexpr struct length final : quantity_spec<dim_length> {
} length;  // Length is a base quantity.

// The second signature defines a derived quantity.
inline constexpr struct area final : quantity_spec<pow<2>(length)> {
} area;  // An area equals length by length.

// The third and fourth signatures add a leaf to a hierarchy of kinds.
inline constexpr struct width final : quantity_spec<length> {
} width;  // Width is a kind of length.

// The fourth signature also refines the calculus required for implicit conversions.
inline constexpr struct angular_measure final :
    quantity_spec<dimensionless, arc_length / radius, is_kind> {
} angular_measure;  // Requires an arc length per radius, not just any quantity of dimension one.
\end{codeblock}
\end{example}

\begin{codeblock}
namespace mp_units {

template<@\exposconceptnc{DerivedQuantitySpecExpr}@... Expr>
struct @\exposidnc{derived-quantity-spec-impl}@ :
    @\exposidnc{quantity-spec-interface}@,
    @\exposidnc{expr-fractions}@<dimensionless, Expr...> {
  using @\exposidnc{base-type}@ = @\exposidnc{derived-quantity-spec-impl}@;
  using @\exposidnc{base}@ = @\exposidnc{expr-fractions}@<dimensionless, Expr...>;

  static constexpr @\libconcept{Dimension}@ auto dimension =
    @\exposidnc{expr-map}@<@\exposidnc{to-dimension}@, derived_dimension, struct dimension_one>(@\exposidnc{base}@{});
  static constexpr quantity_character character =
    @\exposidnc{derived-quantity-character}@(typename @\exposidnc{base}@::@\exposidnc{num}@{}, typename @\exposidnc{base}@::@\exposidnc{den}@{});
};

template<@\exposconceptnc{DerivedQuantitySpecExpr}@... Expr>
struct @\libglobal{derived_quantity_spec}@ final : @\exposidnc{derived-quantity-spec-impl}@<Expr...> {};

}
\end{codeblock}

\pnum
A specialization of \tcode{derived_quantity_spec}
is returned from a quantity calculus not equal to a named quantity.
\begin{example}
\begin{codeblock}
auto area = pow<2>(length);
static_assert(decltype(area) == ^derived_quantity_spec<power<length, 2>>);
\end{codeblock}
\end{example}

\begin{codeblock}
namespace mp_units {

inline constexpr struct @\libglobal{dimensionless}@ final : quantity_spec<derived_quantity_spec<>> {
} @\libglobal{dimensionless}@;

}
\end{codeblock}

\pnum
\tcode{dimensionless} represents the base quantity of dimension one\irefiev{112-01-13}.

\begin{codeblock}
namespace mp_units {

template<typename T>
concept @\defexposconceptnc{QuantitySpecWithNoSpecifiers}@ = @\exposconceptnc{NamedQuantitySpec}@<T> || @\exposconceptnc{DerivedQuantitySpec}@<T>;

template<typename Q>
  requires @\exposconceptnc{QuantitySpecWithNoSpecifiers}@<Q> && @\exposconceptnc{SameQuantitySpec}@<@\exposidnc{get-kind-tree-root}@(Q{}), Q{}>
struct @\libglobal{kind_of_}@ final : Q::@\exposidnc{base-type}@ {
  using @\exposidnc{base-type}@ = kind_of_;
  static constexpr auto @\exposidnc{quantity-spec}@ = Q{};
};

}
\end{codeblock}

\pnum
\tcode{kind_of<Q>} specifies \tcode{Q} to be treated as a quantity kind.

\begin{codeblock}
namespace mp_units {

template<@\libconcept{QuantitySpec}@ auto... From, @\libconcept{QuantitySpec}@ Q>
consteval @\libconcept{QuantitySpec}@ auto @\exposidnc{clone-kind-of}@(Q q)
{
  if constexpr ((... && @\exposconceptnc{QuantityKindSpec}@<decltype(From)>))
    return kind_of<Q{}>;
  else
    return q;
}

template<@\libconcept{QuantitySpec}@ Q>
consteval auto @\exposidnc{remove-kind}@(Q q)
{
  if constexpr (@\exposconceptnc{QuantityKindSpec}@<Q>)
    return Q::@\exposidnc{quantity-spec}@;
  else
    return q;
}

}
\end{codeblock}

\begin{itemdecl}
template<std::intmax_t Num, std::intmax_t Den = 1, @\libconcept{QuantitySpec}@ Q>
  requires(Den != 0)
consteval @\libconcept{QuantitySpec}@ auto @\liboverload{pow}{\cname{QuantitySpec}}@(Q q);
\end{itemdecl}

\begin{itemdescr}
\pnum
Computes $\tcode{q}^{\tcode{Num}/\tcode{Den}}$.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if constexpr (Num == 0 || q == dimensionless)
  return dimensionless;
else if constexpr (@\exposidnc{ratio}@{Num, Den} == 1)
  return q;
else if constexpr (@\exposconceptnc{DerivedQuantitySpec}@<Q>)
  return @\exposidnc{clone-kind-of}@<q>(
    @\exposidnc{expr-pow}@<Num, Den, derived_quantity_spec, struct dimensionless>(@\exposidnc{remove-kind}@(q)));
else if constexpr (Den == 1)
  return @\exposidnc{clone-kind-of}@<q>(derived_quantity_spec<power<decltype(@\exposidnc{remove-kind}@(q)), Num>>{});
else
  return @\exposidnc{clone-kind-of}@<q>(
    derived_quantity_spec<power<decltype(@\exposidnc{remove-kind}@(q)), Num, Den>>{});
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
consteval bool @\libglobal{implicitly_convertible}@(QuantitySpec auto from, QuantitySpec auto to);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
TBD.
\end{itemdescr}

\begin{itemdecl}
consteval bool @\libglobal{explicitly_convertible}@(QuantitySpec auto from, QuantitySpec auto to);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
TBD.
\end{itemdescr}

\begin{itemdecl}
consteval bool @\libglobal{castable}@(QuantitySpec auto from, QuantitySpec auto to);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
TBD.
\end{itemdescr}

\begin{itemdecl}
consteval bool @\libglobal{interconvertible}@(QuantitySpec auto qs1, QuantitySpec auto qs2);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{implicitly_convertible(qs1, qs2) \&\& implicitly_convertible(qs2, qs1)}.
\end{itemdescr}

\begin{codeblock}
namespace mp_units {

template<@\libconcept{QuantitySpec}@ Q>
  requires requires(Q q) { @\exposidnc{get-kind-tree-root}@(q); }
using @\exposidnc{to-kind}@ = decltype(@\exposidnc{get-kind-tree-root}@(Q{}));

template<@\libconcept{QuantitySpec}@ Q>
consteval @\libconcept{QuantitySpec}@ auto @\exposidnc{get-kind-tree-root}@(Q q)
{
  auto defined_as_kind = []<auto... Args>(quantity_spec<Args...>) {
    return (... || type_of(^Args) == ^struct is_kind);
  };

  if constexpr (@\exposconceptnc{QuantityKindSpec}@<Q>) {
    return @\exposidnc{remove-kind}@(q);
  } else if constexpr (defined_as_kind(q)) {
    return q;
  } else if constexpr (requires { Q::@\exposidnc{parent}@; }) {
    return @\exposidnc{get-kind-tree-root}@(Q::@\exposidnc{parent}@);
  } else if constexpr (@\exposconceptnc{DerivedQuantitySpec}@<Q>) {
    return @\exposidnc{expr-map}@<@\exposidnc{to-kind}@, derived_quantity_spec, struct dimensionless>(q);
  } else {
    return q;
  }
}

}
\end{codeblock}

\begin{itemdecl}
template<@\libconcept{QuantitySpec}@ Q>
consteval @\exposconceptnc{QuantityKindSpec}@ auto @\libglobal{get_kind}@(Q q);
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{kind_of<\exposidnc{get-kind-tree-root}(q)>}.
\end{itemdescr}

\begin{itemdecl}
consteval @\libconcept{QuantitySpec}@ auto @\libglobal{get_common_quantity_spec}@(@\libconcept{QuantitySpec}@ auto... qs)
  requires @\seebelownc@;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let
\begin{itemize}
\item
\tcode{q1} be \tcode{qs...[0]},
\item
\tcode{q2} be \tcode{qs...[1]},
\item
\tcode{Q1} be \tcode{decltype(q1)},
\item
\tcode{Q2} be \tcode{decltype(q2)}, and
\item
\tcode{rest} be a pack denoting the elements of \tcode{qs} without \tcode{q1} and \tcode{q2}.
\end{itemize}

\pnum
The expression in the \fakegrammarterm{requires-clause} is equivalent to:
\begin{codeblock}
(sizeof...(qs) != 0 &&
 (sizeof...(qs) == 1 ||
  (sizeof...(qs) == 2 &&
   (@\exposconceptnc{QuantitySpecConvertibleTo}@<@\exposidnc{get-kind-tree-root}@(Q1{}), @\exposidnc{get-kind-tree-root}@(Q2{})> ||
    @\exposconceptnc{QuantitySpecConvertibleTo}@<@\exposidnc{get-kind-tree-root}@(Q2{}), @\exposidnc{get-kind-tree-root}@(Q1{})>)) ||
  requires { get_common_quantity_spec(get_common_quantity_spec(q1, q2), rest...); }))
\end{codeblock}

\pnum
\effects
Equivalent to:
\begin{codeblock}
if constexpr (sizeof...(qs) == 1)
  return q1;
else if constexpr (sizeof...(qs) == 2) {
  using QQ1 = decltype(remove_kind(q1));
  using QQ2 = decltype(remove_kind(q2));

  if constexpr (^Q1 == ^Q2)
    return q1;
  else if constexpr (@\exposconceptnc{NestedQuantityKindSpecOf}@<q1, q2>)
    return QQ1{};
  else if constexpr (@\exposconceptnc{NestedQuantityKindSpecOf}@<q2, q1>)
    return QQ2{};
  else if constexpr ((@\exposconceptnc{QuantityKindSpec}@<Q1> && !@\exposconceptnc{QuantityKindSpec}@<Q2>) ||
                     (@\exposconceptnc{DerivedQuantitySpec}@<QQ1> && @\exposconceptnc{NamedQuantitySpec}@<QQ2> &&
                      implicitly_convertible(q1, q2)))
    return q2;
  else if constexpr ((!@\exposconceptnc{QuantityKindSpec}@<Q1> && @\exposconceptnc{QuantityKindSpec}@<Q2>) ||
                     (@\exposconceptnc{NamedQuantitySpec}@<QQ1> && @\exposconceptnc{DerivedQuantitySpec}@<QQ2> &&
                      implicitly_convertible(q2, q1)))
    return q1;
  else if constexpr (constexpr auto common_base = @\exposidnc{get-common-base}@(q1, q2))
    return [:*common_base:];
  else if constexpr (implicitly_convertible(q1, q2))
    return q2;
  else if constexpr (implicitly_convertible(q2, q1))
    return q1;
  else if constexpr (implicitly_convertible(@\exposidnc{get-kind-tree-root}@(q1), @\exposidnc{get-kind-tree-root}@(q2)))
    return @\exposidnc{get-kind-tree-root}@(q2);
  else
    return @\exposidnc{get-kind-tree-root}@(q1);
} else
  return get_common_quantity_spec(get_common_quantity_spec(q1, q2), rest...);
\end{codeblock}
\end{itemdescr}

\pnum
Let \tcode{Q} be a specialization of \tcode{quantity_spec} with a \exposidnc{parent} member.

% Untested algorithm.
\begin{codeblock}
namespace mp_units {

consteval std::vector<std::meta::info> @\exposidnc{quantity-spec-hierarchy}@(std::meta::info q)
{
  auto get_parent = [](std::meta::info q) -> std::optional<std::meta::info> {
    auto mems = members_of(q);
    auto it = std::ranges::find_if(mems, [parent_id = identifier_of(^Q::@\exposidnc{parent}@)](auto m) {
      return has_identifier(m) && identifier_of(m) == parent_id;
    });
    if (it != args.end()) return *it;
    return std::nullopt;
  };
  std::vector<std::meta::info> res{q};
  std::optional<std::meta::info> parent;
  while (parent = get_parent(res.back())) {
    res.push_back(*parent);
  }
  return res;
}

}
\end{codeblock}

\begin{itemdecl}
template<@\libconcept{QuantitySpec}@ A, @\libconcept{QuantitySpec}@ B>
consteval std::optional<std::meta::info> @\exposidnc{get-common-base}@(A a, B b);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: % Untested algorithm.
\begin{codeblock}
auto hier_a = @\exposidnc{quantity-spec-hierarchy}@(^a);
auto hier_b = @\exposidnc{quantity-spec-hierarchy}@(^b);
auto max_valid_depth = std::min(hier_a.size(), hier_b.size());
auto res =
  std::ranges::mismatch(std::span{hier_a}.last(max_valid_depth),
                        std::span{hier_b}.last(max_valid_depth), std::not_equal_to);
if (to_address(res.in1) != to_address(hier_a.end())) {
  return *res.in1;
}
return std::nullopt;
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template<@\libconcept{QuantitySpec}@ Child, @\libconcept{QuantitySpec}@ Parent>
consteval bool @\exposidnc{is-child-of}@(Child ch, Parent p);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: % Untested algorithm.
\begin{codeblock}
if constexpr (Child{} == Parent{})
  return true;
else {
  auto hier_ch = @\exposidnc{quantity-spec-hierarchy}@(^ch);
  auto hier_p = @\exposidnc{quantity-spec-hierarchy}@(^p);
  if (hier_p.size() > hier_ch.size())
    return false;
  else
    return std::span{hier_ch}.last(hier_p.size())[0] == ^p;
}
\end{codeblock}
\end{itemdescr}

\rSec1[qty.mag]{Magnitude}

\rSec1[qty.unit]{Unit}

\begin{itemdecl}
template<typename T>
concept @\deflibconcept{Unit}@ = @\exposconceptnc{tag-type}@<T> && std::@\stdconcept{derived_from}@<T, @\exposidnc{unit-interface}@>;
template<typename T>
concept @\deflibconcept{UnitOf}@ = @\unspecnc@;
template<typename T>
concept @\defexposconcept{AssociatedUnit}@ = @\unspecnc@;
\end{itemdecl}

\rSec1[qty.ref]{Reference}

\begin{itemdecl}
template<typename T>
concept @\deflibconcept{Reference}@ = @\exposconceptnc{AssociatedUnit}@<T> || @\exposidnc{is-specialization-of}@(^T, ^reference);
\end{itemdecl}

\rSec1[qty.rep]{Representation}

\rSec2[qty.rep.traits]{Traits}

\rSec3[qty.fp.traits]{Floating-point}

\begin{itemdecl}
template<typename T>
struct @\exposidnc{actual-value-type}@ : @\exposidnc{cond-value-type}@<T> {}; // see \refcpp{readable.traits}

template<typename T>
  requires(!type_is_pointer(^T) && !type_is_array(^T)) &&
          requires { typename std::indirectly_readable_traits<T>::value_type; }
struct @\exposidnc{actual-value-type}@<T> : std::indirectly_readable_traits<T> {};

template<typename T>
using @\exposidnc{actual-value-type-t}@ = @\exposidnc{actual-value-type}@<T>::value_type;

template<typename Rep>
constexpr bool @\libglobal{treat_as_floating_point}@ =
  std::chrono::treat_as_floating_point_v<Rep> ||
  std::chrono::treat_as_floating_point_v<@\exposidnc{actual-value-type-t}@<Rep>>;
\end{itemdecl}

\begin{itemdescr}
\pnum
The quantity types\iref{term.quantity.type} use \tcode{treat_as_floating_point}
to help determine whether implicit conversions are allowed among them.

\pnum
\remarks
Pursuant to \refcpp{namespace.std}\iref{spec.ext},
users may specialize \tcode{treat_as_floating_point}
for cv-unqualified program-defined types.
Such specializations shall be usable in constant expressions\irefcpp{expr.const}
and have type \tcode{const bool}.
\end{itemdescr}

\rSec3[qty.set.traits]{Set}

\begin{itemdecl}
template<typename Rep>
constexpr bool @\libglobal{is_scalar}@ =
  type_is_floating_point(^Rep) || (type_is_integral(^Rep) && ^Rep != ^bool);

template<typename Rep>
constexpr bool @\libglobal{is_complex}@ = false;

template<typename Rep>
constexpr bool @\libglobal{is_vector}@ = false;

template<typename Rep>
constexpr bool @\libglobal{is_tensor}@ = false;
\end{itemdecl}

\begin{itemdescr}
\pnum
Some quantities are defined as having a numerical value\irefiev{112-01-29} of a specific set\irefiev{102-01-02}.
A quantity type\iref{term.quantity.type} \tcode{Q} uses these traits
to determine the set \tcode{Q::rep} should represent.

\pnum
\remarks
Pursuant to \refcpp{namespace.std}\iref{spec.ext},
users may specialize \tcode{is_scalar}, \tcode{is_complex}, \tcode{is_vector}, and \tcode{is_tensor} to \tcode{true}
for cv-unqualified program-defined types
which respectively represent
a scalar\irefiev{102-02-18},
a complex number\irefiev{102-02-09},
a vector\irefiev{102-03-04}, and
% FIXME Undefined term.
a tensor,
and \tcode{false} for types which respectively do not.
Such specializations shall be usable in constant expressions\irefcpp{expr.const}
and have type \tcode{const bool}.
\end{itemdescr}

\rSec2[qty.rep.concepts]{Concepts}

\begin{itemdecl}
template<typename T, typename U>
concept @\defexposconceptnc{CommonTypeWith}@ = std::@\stdconcept{same_as}@<std::common_type_t<T, U>, std::common_type_t<U, T>> &&
                         std::@\stdconcept{constructible_from}@<std::common_type_t<T, U>, T> &&
                         std::@\stdconcept{constructible_from}@<std::common_type_t<T, U>, U>;

template<typename T, typename U = T>
concept @\defexposconceptnc{ScalableNumber}@ = std::@\stdconcept{regular_invocable}@<std::multiplies<>, T, U> &&
                         std::@\stdconcept{regular_invocable}@<std::divides<>, T, U>;

template<typename T>
concept @\defexposconceptnc{CastableNumber}@ =
  @\exposconceptnc{CommonTypeWith}@<T, std::intmax_t> && @\exposconceptnc{ScalableNumber}@<std::common_type_t<T, std::intmax_t>>;

template<typename T>
concept @\defexposconceptnc{Scalable}@ =
  @\exposconceptnc{CastableNumber}@<T> ||
  (@\exposconceptnc{CastableNumber}@<@\exposidnc{actual-value-type-t}@<T>> &&
   @\exposconceptnc{ScalableNumber}@<T, std::common_type_t<@\exposidnc{actual-value-type-t}@<T>, std::intmax_t>>);

template<typename T>
concept @\defexposconceptnc{WeaklyRegular}@ = std::@\stdconcept{copyable}@<T> && std::@\stdconcept{equality_comparable}@<T>;

template<typename T>
concept @\deflibconcept{Representation}@ = (is_scalar<T> || is_complex<T> || is_vector<T> || is_tensor<T>) &&
                         @\exposconceptnc{WeaklyRegular}@<T> && @\exposconceptnc{Scalable}@<T>;

template<typename T, quantity_character Ch>
concept @\deflibconcept{RepresentationOf}@ =
  @\libconcept{Representation}@<T> && ((Ch == quantity_character::scalar && is_scalar<T>) ||
                        (Ch == quantity_character::complex && is_complex<T>) ||
                        (Ch == quantity_character::vector && is_vector<T>) ||
                        (Ch == quantity_character::tensor && is_tensor<T>));
\end{itemdecl}

\rSec1[qty.types]{Quantity types}

\rSec2[qty.traits]{Traits}

\rSec3[qty.val.traits]{Values}

\begin{codeblock}
namespace mp_units {

template<typename Rep>
struct @\libglobal{quantity_values}@ : std::chrono::duration_values<Rep> {
  static constexpr Rep one() noexcept;
};

}
\end{codeblock}

\pnum
The requirements on \tcode{std::chrono::duration_values<Rep>}\irefcpp{time.traits.duration.values}
also apply to \tcode{quantity_values<Rep>}.

\begin{itemdecl}
static constexpr Rep one() noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
if constexpr (requires {
                { std::chrono::duration_values<Rep>::one() } -> std::@\stdconcept{same_as}@<Rep>;
              })
  return std::chrono::duration_values<Rep>::one();
else
  return Rep(1);
\end{codeblock}

\pnum
\remarks
The value returned shall be the neutral element for multiplication\irefiev{102-01-19}.
\end{itemdescr}

\rSec3[qty.compat.traits]{Compatibility}

\pnum
The interfaces specified in this subclause
are used by the quantity types\iref{term.quantity.type}
to specify conversions with other types representing quantities.
\ref{qty.chrono} implements them for \tcode{std::chrono::duration} and \tcode{std::chrono::time_point}.

\begin{itemdecl}
template<typename T, template<typename> typename Traits>
concept @\defexposconceptnc{qty-like}@ = requires(const T& qty, const Traits<T>::rep& num) {
  requires !@\exposidnc{is-specialization-of}@(^T, ^quantity);
  requires !@\exposidnc{is-specialization-of}@(^T, ^quantity_point);
  { Traits<T>::to_numerical_value(qty) } -> std::@\stdconcept{same_as}@<typename Traits<T>::rep>;
  { Traits<T>::from_numerical_value(num) } -> std::@\stdconcept{same_as}@<T>;
  { Traits<T>::explicit_import } -> std::same_as<const bool>;
  { Traits<T>::explicit_export } -> std::same_as<const bool>;
  typename std::bool_constant<Traits<T>::explicit_import>;
  typename std::bool_constant<Traits<T>::explicit_export>;
};

template<typename T>
concept @\deflibconcept{quantity_like}@ =                 //
  @\exposconceptnc{qty-like}@<T, quantity_like_traits> &&  //
  requires {
    typename quantity<quantity_like_traits<T>::reference, typename quantity_like_traits<T>::rep>;
  };

template<typename T>
concept @\deflibconcept{quantity_point_like}@ =
  @\exposconceptnc{qty-like}@<T, quantity_point_like_traits> &&  //
  requires {
    typename quantity_point<quantity_point_like_traits<T>::reference,
                            typename quantity_point_like_traits<T>::point_origin,
                            typename quantity_point_like_traits<T>::rep>;
  };
\end{itemdecl}

\pnum
In the following descriptions, let
\begin{itemize}
\item
\tcode{Traits} be \tcode{quantity_like_traits} or \tcode{quantity_point_like_traits},
\item
\tcode{Q} be a type for which \tcode{Traits<Q>} is specialized,
\item
\tcode{qty} be an lvalue of type \tcode{const Q}, and
\item
\tcode{num} be an lvalue of type \tcode{const Tratis<Q>::rep}.
\end{itemize}

\pnum
\tcode{Q} models \tcode{\exposconceptnc{qty-like}<Traits>} if and only if:
\begin{itemize}
\item
\tcode{Traits<Q>::to_numerical_value(qty)} returns the numerical value\irefiev{112-01-29} of \tcode{qty}.
\item
\tcode{Traits<Q>::from_numerical_value(num)} returns a \tcode{Q} with numerical value \tcode{num}.
\item
If \tcode{Traits} is \tcode{quantity_point_like_traits},
both numerical values are offset from \tcode{Traits<Q>::point_origin}.
\end{itemize}

\pnum
If the following expression is \tcode{true}, the specified conversion will be explicit.
\begin{itemize}
\item
\tcode{Traits<Q>::explicit_import} for the conversion from \tcode{Q} to a quantity type.
\item
\tcode{Traits<Q>::explicit_export} for the conversion from a quantity type to \tcode{Q}.
\end{itemize}

\rSec2[qty.types.general]{General}

\pnum
\label{term.quantity.type}
A \defnadj{quantity}{type}
is a type \tcode{\placeholder{Q}}
that is a specialization of \tcode{quantity} or \tcode{quantity_point}.
\tcode{\placeholder{Q}} represents the value of a quantity\irefiev{112-01-28}
with \tcode{\placeholdernc{Q}::rep} as its number
and \tcode{\placeholdernc{Q}::reference} as its reference.
\tcode{\placeholder{Q}} is a structural type\irefcppx{temp.param}{term.structural.type}
if \tcode{\placeholdernc{Q}::rep} is a structural type.

\pnum
Each class template defined in subclauses \ref{qty} and \ref{qty.pt}
have data members and special members specified below, and
have no base classes or members other than those specified.

\rSec2[qty.concepts]{Quantity concepts}

\begin{itemdecl}
template<typename T>
concept @\deflibconcept{Quantity}@ = @\unspecnc@;
\end{itemdecl}

\rSec2[qty]{Class template \tcode{quantity}}

\begin{codeblock}
namespace mp_units {

template<auto R1, auto R2, typename Rep1, typename Rep2>
concept @\defexposconceptnc{same-value-as}@ =
  equivalent(get_unit(R1), get_unit(R2)) && std::@\stdconcept{convertible_to}@<Rep1, Rep2>;

template<@\libconcept{Reference}@ auto R, @\libconcept{RepresentationOf}@<get_quantity_spec(R).character> Rep = double>
class @\libglobal{quantity}@ {
public:
  Rep @\exposidnc{numerical-value}@;

  // member types and values
  static constexpr @\libconcept{Reference}@ auto reference = R;
  static constexpr @\libconcept{QuantitySpec}@ auto quantity_spec = get_quantity_spec(reference);
  static constexpr @\libconcept{Dimension}@ auto dimension = quantity_spec.dimension;
  static constexpr @\libconcept{Unit}@ auto unit = get_unit(reference);
  using rep = Rep;

  // static member functions

  static constexpr quantity zero() noexcept
    requires requires { quantity_values<rep>::zero(); }
  {
    return {quantity_values<rep>::zero(), R};
  }

  static constexpr quantity one() noexcept
    requires requires { quantity_values<rep>::one(); }
  {
    return {quantity_values<rep>::one(), R};
  }

  static constexpr quantity min() noexcept
    requires requires { quantity_values<rep>::min(); }
  {
    return {quantity_values<rep>::min(), R};
  }

  static constexpr quantity max() noexcept
    requires requires { quantity_values<rep>::max(); }
  {
    return {quantity_values<rep>::max(), R};
  }

  // construction, assignment, destruction

  quantity() = default;
  quantity(const quantity&) = default;
  quantity(quantity&&) = default;
  ~quantity() = default;

  template<typename FwdValue, @\libconcept{Reference}@ R2>
    requires @\exposconceptnc{same-value-as}@<R2{}, R, [:type_remove_cvref(^FwdValue):], Rep>
  constexpr quantity(FwdValue&& v, R2) : @\exposidnc{numerical-value}@(std::forward<FwdValue>(v))
  {
  }
};

}
\end{codeblock}

\pnum
Let \tcode{\placeholder{Q}} be a specialization of \tcode{quantity}.
\begin{itemize}
\item
If \tcode{Rep} is a scalar\iref{qty.set.traits},
\tcode{\placeholder{Q}} represents a scalar quantity\irefiev{102-02-19}.
% FIXME What if `Rep` is a complex number?
\item
If \tcode{Rep} is a vector\iref{qty.set.traits},
\tcode{\placeholder{Q}} represents a vector\irefiev{102-03-04}.
% FIXME What if `Rep` is a tensor?
\end{itemize}

\rSec2[qty.pt.concepts]{Quantity point concepts}

\begin{itemdecl}
template<typename T>
concept @\deflibconcept{point_origin}@ = @\unspecnc@;
\end{itemdecl}

\rSec2[qty.pt]{Class template \tcode{quantity_point}}

\begin{codeblock}
namespace mp_units {

template<@\unspec@>
class @\libglobal{quantity_point}@ { @\unspec@ };

}
\end{codeblock}

\pnum
\label{term.quantity.point.type}
A \defnadj{quantity point}{type} is a specialization of \tcode{quantity_point}.
Let \tcode{\placeholder{Q}} be a quantity point type.
\tcode{\placeholdernc{Q}::point_origin} represents
the origin point of a position vector\irefiev{102-03-15}
or of a component\irefiev{102-03-10} thereof.
\begin{itemize}
\item
If \tcode{Rep} is a scalar\iref{qty.set.traits},
\tcode{\placeholder{Q}} represents the scalar quantity\irefiev{102-02-19}
of a position vector.
% FIXME What if `Rep` is a complex number?
\item
If \tcode{Rep} is a vector\iref{qty.set.traits},
\tcode{\placeholder{Q}} represents a position vector.
% FIXME What if `Rep` is a tensor?
\end{itemize}

\rSec1[qty.systems]{Systems}

\rSec1[qty.chrono]{\tcode{std::chrono} compatibility}

\begin{codeblock}
namespace mp_units {

template<typename Period>
consteval auto @\exposidnc{time-unit-from-chrono-period}@()
{
  using namespace si;

  if constexpr (is_same_v<Period, std::chrono::nanoseconds::period>)
    return nano<second>;
  else if constexpr (is_same_v<Period, std::chrono::microseconds::period>)
    return micro<second>;
  else if constexpr (is_same_v<Period, std::chrono::milliseconds::period>)
    return milli<second>;
  else if constexpr (is_same_v<Period, std::chrono::seconds::period>)
    return second;
  else if constexpr (is_same_v<Period, std::chrono::minutes::period>)
    return minute;
  else if constexpr (is_same_v<Period, std::chrono::hours::period>)
    return hour;
  else if constexpr (is_same_v<Period, std::chrono::days::period>)
    return day;
  else if constexpr (is_same_v<Period, std::chrono::weeks::period>)
    return mag<7> * day;
  else
    return mag_ratio<Period::num, Period::den> * second;
}

template<typename Rep, typename Period>
struct @\libspec{quantity_like_traits}{std::chrono::duration}@<std::chrono::duration<Rep, Period>> {
  static constexpr auto reference = @\exposidnc{time-unit-from-chrono-period}@<Period>();
  using rep = Rep;

  static constexpr bool explicit_import = false;
  static constexpr rep to_numerical_value(const std::chrono::duration<Rep, Period>& q) noexcept(
    std::is_nothrow_copy_constructible_v<rep>)
  {
    return q.count();
  }

  static constexpr bool explicit_export = false;
  static constexpr std::chrono::duration<Rep, Period> from_numerical_value(
    const rep& v) noexcept(std::is_nothrow_copy_constructible_v<rep>)
  {
    return std::chrono::duration<Rep, Period>(v);
  }
};

template<typename Clock>
struct @\libglobal{chrono_point_origin_}@ final : absolute_point_origin<isq::time> {
  using clock = Clock;
};

template<typename Clock, typename Rep, typename Period>
struct @\libspec{quantity_point_like_traits}{std::chrono::time_point}@<
  std::chrono::time_point<Clock, std::chrono::duration<Rep, Period>>> {
  using @\exposidnc{Tp}@ = std::chrono::time_point<Clock, std::chrono::duration<Rep, Period>>;
  static constexpr auto reference = @\exposidnc{time-unit-from-chrono-period}@<Period>();
  static constexpr auto point_origin = chrono_point_origin<Clock>;
  using rep = Rep;

  static constexpr bool explicit_import = false;
  static constexpr rep to_numerical_value(const @\exposid{Tp}@& tp) noexcept(
    std::is_nothrow_copy_constructible_v<rep>)
  {
    return tp.time_since_epoch().count();
  }

  static constexpr bool explicit_export = false;
  static constexpr @\exposidnc{Tp}@ from_numerical_value(const rep& v) noexcept(
    std::is_nothrow_copy_constructible_v<rep>)
  {
    return @\exposidnc{Tp}@(std::chrono::duration<Rep, Period>(v));
  }
};

}
\end{codeblock}
